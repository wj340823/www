package com.sucsoft.gzhbyjwz.util;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.json.JSONObject;

import com.sucsoft.gis.geometry.Coordinate;
import com.sucsoft.gis.geometry.Geometry;
import com.sucsoft.gis.geometry.Polygon;
import com.sucsoft.gis.geometry.GeometryUtil.GeometryType;
import com.sucsoft.gis.geometry.Interfaces.IGeometry;
import com.sucsoft.gis.spatialRelationship.SpatialRelationshipUtil;
import com.sucsoft.gis.util.CommonJsonUtil;

public class GisUtil {
	public static boolean isPointInPolygon(double x, double y, double[][] pointArray) throws Exception {
		if(isNull(pointArray)) {
			throw new Exception("传个面给我啊");
		}
		double[][][] arr = new double[1][][];
		arr[0] = pointArray;
		IGeometry polygon = coords2Geo(arr);
		return SpatialRelationshipUtil.isPointInPolygon(new Coordinate(x,y), (Polygon)polygon);
	}
	
	public static Map<String,Double> getDistancePointToLines(double x, double y, double[][] pointArray) throws Exception {
		if(isNull(pointArray)) {
			throw new Exception("传个线给我啊");
		}
		Map<String,Double> map = new HashMap<>();
		double min = Double.MAX_VALUE;
		List<Coordinate> points = new ArrayList<>();
		Coordinate point = new Coordinate(x, y);
		for(int i=0;i<pointArray.length;i++) {
			double[] array = pointArray[i];
			points.add(new Coordinate(array[0], array[1]));
			
		}
		for(int i=0;i<points.size()-1;i++) {
			Coordinate start = points.get(i);
			Coordinate end = points.get(i+1);
			boolean inline = isPointInline(start, end, point);
			if(inline) {
				map.put("distance", 0.0);
				return map;
			}else {
				Coordinate nearestPoint2line = SpatialRelationshipUtil.getNearestPoint2line(point, points.get(i), points.get(i+1));
				double distance = SpatialRelationshipUtil.getDistanceVincenty(y, x, nearestPoint2line.y, nearestPoint2line.x);
				if(distance<min) {
					min = distance;
					map.put("distance", min);
					map.put("x", nearestPoint2line.x);
					map.put("y", nearestPoint2line.y);
					map.put("endX", end.x);
					map.put("endY", end.y);
				}
			}
		}
		return map;
	}
	
	public static List<Coordinate> getCoordsOutOfDistance(double[][] expect,double[][] actual,double distance) throws Exception {
		List<Coordinate> coordList = new ArrayList<Coordinate>();
		if(isNull(actual)) {
			for(int i=0;i<expect.length;i++) {
				if(i==0||i==expect.length-1) {
					coordList.add(new Coordinate(expect[i][0], expect[i][1]));
				}else {
					coordList.add(new Coordinate(expect[i][0], expect[i][1]));
					coordList.add(new Coordinate(expect[i][0], expect[i][1]));
				}
			}
			return coordList;
		}
		int flag = 0;
		for(int i=0;i<actual.length;i++) {
			Map<String, Double> map = getDistancePointToLines(actual[i][0],actual[i][1],expect);
			Double d = map.get("distance");
			if(d>=distance&&flag==1) {
				flag = 2; //之前的点也超出范围,不放入list中
			}else if(d>=distance&&flag==0){
				flag = 1; //第一次超出范围
				coordList.add(new Coordinate(map.get("x"),map.get("y")));
			}else if(d<distance&&(flag==1||flag==2)) {  //表示之前的点超出范围,而当前点并没有超出
				flag = 0;
				coordList.add(new Coordinate(map.get("x"),map.get("y")));
			}else {
				flag = 0;
			}
			if((i==actual.length-1)&&coordList.size()%2!=0) {  //coordList的长度为单数,表示expect之后的所有点都需标识
				for(int j=0;j<expect.length;j++) {
					if(expect[j][0]==map.get("endX")&&expect[j][1]==map.get("endY")) {
						for(int k=j;k<expect.length;k++) {
							if(k==expect.length-1) {
								coordList.add(new Coordinate(expect[k][0],expect[k][1]));
							}else {
								coordList.add(new Coordinate(expect[k][0],expect[k][1]));
								coordList.add(new Coordinate(expect[k][0],expect[k][1]));
							}
						}
						break;
					}
				}
			}
		}
		return coordList;
	}
	
	public static IGeometry coords2Geo(Object coords) throws Exception {
		JSONObject jo = new JSONObject();
		jo.put("rings", coords);
		String geoString = jo.toString();
		Geometry geo = CommonJsonUtil.jsonGeo2Geo(geoString,
				GeometryType.esriGeometryPolygon);
		return geo;
	}
	
	public static boolean isPointInline(Coordinate sp,Coordinate ep,Coordinate point){
		double x1=sp.x;double y1=sp.y; double x2=ep.x;double y2=ep.y;double x=point.x;double y=point.y;
		if(Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1))<0.0000000001&&(x-x1)*(x-x2)<=0){
			return true;
		}else 
			return false;
	}
	
	public static boolean isNull(double[][] arr) {
		if(arr.length==0) {
			return true;
		}
		for(int i=0;i<arr.length;i++) {
			double[] line = arr[i];
			if(line.length==0) {
				return true;
			}
		}
		return false;
	}
	
//	public static void main(String[] args) throws Exception {
//		double[][] a = new double[3][];
//		double[][] a2 = new double[3][];
//		double[][] a3 = {{},{}};
//		double[] b = {120.86124644159205,25.0515838576686};
//		double[] b2 = {120.91718879166832,25.05490887014849};
//		double[] b3 = {120.88914595691614,25.07413278101273};
//		double[] b4 = {120.8917811698788,25.06554625376154};
//		//double[] b5 = {120.9917811698788,25.06554625376154};
//		a[0] = b;
//		a[1] = b2;
//		a[2] = b3;
//		a2[0] = b;
//		a2[1] = b2;
//		a2[2] = b4;
//		//Map<String, Double> distancePointToLines = getDistancePointToLines(120.891781169878,25.0655462537615,a);
//		//System.out.println(distancePointToLines);
//		List<Coordinate> coordsOutOfDistance = getCoordsOutOfDistance(a,a3,20);
//		System.out.println(coordsOutOfDistance);
//		boolean pointInline = isPointInline(new Coordinate(120.8904435218838,25.0764450022846), new Coordinate(120.8917811698788, 25.06354625376154), new Coordinate(120.8915759692925, 25.06552497370074));
//		System.out.println(pointInline);
//	}
}
